{"ast":null,"code":"import _asyncToGenerator from \"/home/naser/workspace/communer/share-location/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport * as i0 from '@angular/core';\nimport { InjectionToken, PLATFORM_ID, Injectable, Inject, NgModule } from '@angular/core';\nimport { isPlatformBrowser, CommonModule } from '@angular/common';\nimport { Observable, from, combineLatest, Subject } from 'rxjs';\nimport { take } from 'rxjs/operators';\nfunction openDatabase(indexedDB, dbName, version, upgradeCallback) {\n  return new Promise((resolve, reject) => {\n    if (!indexedDB) {\n      reject('IndexedDB not available');\n    }\n    const request = indexedDB.open(dbName, version);\n    let db;\n    request.onsuccess = event => {\n      db = request.result;\n      resolve(db);\n    };\n    request.onerror = event => {\n      reject(`IndexedDB error: ${request.error}`);\n    };\n    if (typeof upgradeCallback === 'function') {\n      request.onupgradeneeded = event => {\n        upgradeCallback(event, db);\n      };\n    }\n  });\n}\nfunction CreateObjectStore(indexedDB, dbName, version, storeSchemas, migrationFactory) {\n  if (!indexedDB) {\n    return;\n  }\n  const request = indexedDB.open(dbName, version);\n  request.onupgradeneeded = event => {\n    const database = event.target.result;\n    storeSchemas.forEach(storeSchema => {\n      if (!database.objectStoreNames.contains(storeSchema.store)) {\n        const objectStore = database.createObjectStore(storeSchema.store, storeSchema.storeConfig);\n        storeSchema.storeSchema.forEach(schema => {\n          objectStore.createIndex(schema.name, schema.keypath, schema.options);\n        });\n      }\n    });\n    const storeMigrations = migrationFactory && migrationFactory();\n    if (storeMigrations) {\n      Object.keys(storeMigrations).map(k => parseInt(k, 10)).filter(v => v > event.oldVersion).sort((a, b) => a - b).forEach(v => {\n        storeMigrations[v](database, request.transaction);\n      });\n    }\n    database.close();\n  };\n  request.onsuccess = e => {\n    e.target.result.close();\n  };\n}\nfunction DeleteObjectStore(dbName, version, storeName) {\n  if (!dbName || !version || !storeName) {\n    throw Error('Params: \"dbName\", \"version\", \"storeName\" are mandatory.');\n  }\n  return new Observable(obs => {\n    try {\n      const newVersion = version + 1;\n      const request = indexedDB.open(dbName, newVersion);\n      request.onupgradeneeded = event => {\n        const database = event.target.result;\n        database.deleteObjectStore(storeName);\n        database.close();\n        console.log('onupgradeneeded');\n        obs.next(true);\n        obs.complete();\n      };\n      request.onerror = e => obs.error(e);\n    } catch (error) {\n      obs.error(error);\n    }\n  });\n}\nfunction validateStoreName(db, storeName) {\n  return db.objectStoreNames.contains(storeName);\n}\nfunction validateBeforeTransaction(db, storeName, reject) {\n  if (!db) {\n    reject('You need to use the openDatabase function to create a database before you query it!');\n  }\n  if (!validateStoreName(db, storeName)) {\n    reject(`objectStore does not exists: ${storeName}`);\n  }\n}\nfunction createTransaction(db, options) {\n  const trans = db.transaction(options.storeName, options.dbMode);\n  trans.onerror = options.error;\n  trans.onabort = options.abort;\n  return trans;\n}\nfunction optionsGenerator(type, storeName, reject, resolve) {\n  return {\n    storeName,\n    dbMode: type,\n    error: e => {\n      reject(e);\n    },\n    abort: e => {\n      reject(e);\n    }\n  };\n}\nvar DBMode;\n(function (DBMode) {\n  DBMode[\"readonly\"] = \"readonly\";\n  DBMode[\"readwrite\"] = \"readwrite\";\n})(DBMode || (DBMode = {}));\nconst CONFIG_TOKEN = new InjectionToken(null);\nclass NgxIndexedDBService {\n  constructor(dbConfigs, platformId) {\n    this.dbConfigs = dbConfigs;\n    this.platformId = platformId;\n    this.defaultDatabaseName = null;\n    this.isBrowser = isPlatformBrowser(this.platformId);\n    if (this.isBrowser) {\n      this.indexedDB = window.indexedDB || window.mozIndexedDB || window.webkitIndexedDB || window.msIndexedDB;\n      const dbConfigs = Object.values(this.dbConfigs);\n      const isOnlyConfig = dbConfigs.length === 1;\n      for (const dbConfig of dbConfigs) {\n        this.instanciateConfig(dbConfig, isOnlyConfig);\n      }\n    }\n  }\n  instanciateConfig(dbConfig, isOnlyConfig) {\n    if (!dbConfig.name) {\n      throw new Error('NgxIndexedDB: Please, provide the dbName in the configuration');\n    }\n    if (!dbConfig.version) {\n      throw new Error('NgxIndexedDB: Please, provide the db version in the configuration');\n    }\n    if ((dbConfig.isDefault ?? false) && this.defaultDatabaseName) {\n      // A default DB is already configured, throw an error\n      throw new Error('NgxIndexedDB: Only one database can be set as default');\n    }\n    if ((dbConfig.isDefault ?? false) && !this.defaultDatabaseName || isOnlyConfig) {\n      this.defaultDatabaseName = dbConfig.name;\n      this.selectedDb = dbConfig.name;\n    }\n    CreateObjectStore(this.indexedDB, dbConfig.name, dbConfig.version, dbConfig.objectStoresMeta, dbConfig.migrationFactory);\n    openDatabase(this.indexedDB, dbConfig.name).then(db => {\n      if (db.version !== dbConfig.version) {\n        if (process.env.NODE_ENV !== 'production') {\n          console.warn(`\n            Your DB Config doesn't match the most recent version of the DB with name ${dbConfig.name}, please update it\n            DB current version: ${db.version};\n            Your configuration: ${dbConfig.version};\n            `);\n          console.warn(`Using latest version ${db.version}`);\n        }\n        this.dbConfigs[dbConfig.name].version = db.version;\n      }\n    });\n  }\n  get dbConfig() {\n    return this.dbConfigs[this.selectedDb];\n  }\n  /**\n   * Selects a database for the current context.\n   * @param {string} [databaseName=undefined] Database name to select.\n   */\n  selectDb(databaseName) {\n    databaseName = databaseName ?? this.defaultDatabaseName;\n    if (!databaseName) {\n      // Name is still null, it means that there is no default database set\n      // and the database name was not specified while calling a method\n      throw new Error(`No database name specified and no default database set.`);\n    }\n    if (!Object.keys(this.dbConfigs).includes(databaseName)) {\n      throw new Error(`NgxIndexedDB: Database ${databaseName} is not initialized.`);\n    }\n    this.selectedDb = databaseName;\n  }\n  /**\n   * Allows to crate a new object store ad-hoc\n   * @param storeName The name of the store to be created\n   * @param migrationFactory The migration factory if exists\n   */\n  createObjectStore(storeSchema, migrationFactory) {\n    const storeSchemas = [storeSchema];\n    CreateObjectStore(this.indexedDB, this.dbConfig.name, ++this.dbConfig.version, storeSchemas, migrationFactory);\n  }\n  /**\n   * Adds new entry in the store and returns its key\n   * @param storeName The name of the store to add the item\n   * @param value The entry to be added\n   * @param key The optional key for the entry\n   */\n  add(storeName, value, key) {\n    return new Observable(obs => {\n      openDatabase(this.indexedDB, this.dbConfig.name, this.dbConfig.version).then(db => {\n        const transaction = createTransaction(db, optionsGenerator(DBMode.readwrite, storeName, e => obs.error(e)));\n        const objectStore = transaction.objectStore(storeName);\n        const request = Boolean(key) ? objectStore.add(value, key) : objectStore.add(value);\n        request.onsuccess = /*#__PURE__*/function () {\n          var _ref = _asyncToGenerator(function* (evt) {\n            const result = evt.target.result;\n            const getRequest = objectStore.get(result);\n            getRequest.onsuccess = event => {\n              obs.next(event.target.result);\n              obs.complete();\n            };\n            getRequest.onerror = event => {\n              obs.error(event);\n            };\n          });\n          return function (_x) {\n            return _ref.apply(this, arguments);\n          };\n        }();\n        request.onerror = event => {\n          obs.error(event);\n        };\n      }).catch(error => obs.error(error));\n    });\n  }\n  /**\n   * Adds new entries in the store and returns its key\n   * @param storeName The name of the store to add the item\n   * @param values The entries to be added containing optional key attribute\n   */\n  bulkAdd(storeName, values) {\n    const promises = new Promise((resolve, reject) => {\n      openDatabase(this.indexedDB, this.dbConfig.name, this.dbConfig.version).then(db => {\n        const transaction = createTransaction(db, optionsGenerator(DBMode.readwrite, storeName, resolve, reject));\n        const objectStore = transaction.objectStore(storeName);\n        const results = values.map(value => {\n          return new Promise((resolve1, reject1) => {\n            const key = value.key;\n            delete value.key;\n            const request = Boolean(key) ? objectStore.add(value, key) : objectStore.add(value);\n            request.onsuccess = evt => {\n              const result = evt.target.result;\n              resolve1(result);\n            };\n          });\n        });\n        resolve(Promise.all(results));\n      }).catch(reason => reject(reason));\n    });\n    return from(promises);\n  }\n  /**\n   * Delete entries in the store and returns current entries in the store\n   * @param storeName The name of the store to add the item\n   * @param keys The keys to be deleted\n   */\n  bulkDelete(storeName, keys) {\n    const promises = keys.map(key => {\n      return new Promise((resolve, reject) => {\n        openDatabase(this.indexedDB, this.dbConfig.name, this.dbConfig.version).then(db => {\n          const transaction = createTransaction(db, optionsGenerator(DBMode.readwrite, storeName, reject, resolve));\n          const objectStore = transaction.objectStore(storeName);\n          objectStore.delete(key);\n          transaction.oncomplete = () => {\n            this.getAll(storeName).pipe(take(1)).subscribe(newValues => {\n              resolve(newValues);\n            });\n          };\n        }).catch(reason => reject(reason));\n      });\n    });\n    return from(Promise.all(promises));\n  }\n  /**\n   * Returns entry by key.\n   * @param storeName The name of the store to query\n   * @param key The entry key\n   */\n  getByKey(storeName, key) {\n    return new Observable(obs => {\n      openDatabase(this.indexedDB, this.dbConfig.name, this.dbConfig.version).then(db => {\n        const transaction = createTransaction(db, optionsGenerator(DBMode.readonly, storeName, obs.error));\n        const objectStore = transaction.objectStore(storeName);\n        const request = objectStore.get(key);\n        request.onsuccess = event => {\n          obs.next(event.target.result);\n          obs.complete();\n        };\n        request.onerror = event => {\n          obs.error(event);\n        };\n      }).catch(error => obs.error(error));\n    });\n  }\n  /**\n   * Retrieve multiple entries in the store\n   * @param storeName The name of the store to retrieve the items\n   * @param keys The ids entries to be retrieve\n   */\n  bulkGet(storeName, keys) {\n    const observables = keys.map(key => this.getByKey(storeName, key));\n    return new Observable(obs => {\n      combineLatest(observables).subscribe(values => {\n        obs.next(values);\n        obs.complete();\n      });\n    });\n  }\n  /**\n   * Returns entry by id.\n   * @param storeName The name of the store to query\n   * @param id The entry id\n   */\n  getByID(storeName, id) {\n    return new Observable(obs => {\n      openDatabase(this.indexedDB, this.dbConfig.name, this.dbConfig.version).then(db => {\n        validateBeforeTransaction(db, storeName, e => obs.error(e));\n        const transaction = createTransaction(db, optionsGenerator(DBMode.readonly, storeName, obs.error, obs.next));\n        const objectStore = transaction.objectStore(storeName);\n        const request = objectStore.get(id);\n        request.onsuccess = event => {\n          obs.next(event.target.result);\n        };\n      }).catch(error => obs.error(error));\n    });\n  }\n  /**\n   * Returns entry by index.\n   * @param storeName The name of the store to query\n   * @param indexName The index name to filter\n   * @param key The entry key.\n   */\n  getByIndex(storeName, indexName, key) {\n    return new Observable(obs => {\n      openDatabase(this.indexedDB, this.dbConfig.name, this.dbConfig.version).then(db => {\n        validateBeforeTransaction(db, storeName, e => obs.error(e));\n        const transaction = createTransaction(db, optionsGenerator(DBMode.readonly, storeName, obs.error));\n        const objectStore = transaction.objectStore(storeName);\n        const index = objectStore.index(indexName);\n        const request = index.get(key);\n        request.onsuccess = event => {\n          obs.next(event.target.result);\n          obs.complete();\n        };\n      }).catch(reason => obs.error(reason));\n    });\n  }\n  /**\n   * Return all elements from one store\n   * @param storeName The name of the store to select the items\n   */\n  getAll(storeName) {\n    return new Observable(obs => {\n      openDatabase(this.indexedDB, this.dbConfig.name, this.dbConfig.version).then(db => {\n        validateBeforeTransaction(db, storeName, e => obs.error(e));\n        const transaction = createTransaction(db, optionsGenerator(DBMode.readonly, storeName, obs.error, obs.next));\n        const objectStore = transaction.objectStore(storeName);\n        const request = objectStore.getAll();\n        request.onerror = evt => {\n          obs.error(evt);\n        };\n        request.onsuccess = ({\n          target: {\n            result: ResultAll\n          }\n        }) => {\n          obs.next(ResultAll);\n          obs.complete();\n        };\n      }).catch(error => obs.error(error));\n    });\n  }\n  /**\n   * Adds or updates a record in store with the given value and key. Return all items present in the store\n   * @param storeName The name of the store to update\n   * @param value The new value for the entry\n   */\n  update(storeName, value) {\n    return new Observable(obs => {\n      openDatabase(this.indexedDB, this.dbConfig.name, this.dbConfig.version).then(db => {\n        validateBeforeTransaction(db, storeName, e => obs.error(e));\n        const transaction = createTransaction(db, optionsGenerator(DBMode.readwrite, storeName, e => obs.error(e)));\n        const objectStore = transaction.objectStore(storeName);\n        const request = objectStore.put(value);\n        request.onsuccess = /*#__PURE__*/function () {\n          var _ref2 = _asyncToGenerator(function* (evt) {\n            const result = evt.target.result;\n            const getRequest = objectStore.get(result);\n            getRequest.onsuccess = event => {\n              obs.next(event.target.result);\n              obs.complete();\n            };\n          });\n          return function (_x2) {\n            return _ref2.apply(this, arguments);\n          };\n        }();\n      }).catch(reason => obs.error(reason));\n    });\n  }\n  /**\n   * Adds or updates a record in store with the given value and key. Return all items present in the store\n   * @param storeName The name of the store to update\n   * @param items The values to insert in the DB\n   *\n   * @Return The return value is an Observable with the primary key of the object that was last in given array\n   *\n   * @error If the call to bulkPut fails the transaction will be aborted and previously inserted entities will be deleted\n   */\n  bulkPut(storeName, items) {\n    let transaction;\n    return new Observable(obs => {\n      openDatabase(this.indexedDB, this.dbConfig.name, this.dbConfig.version).then(db => {\n        validateBeforeTransaction(db, storeName, e => obs.error(e));\n        transaction = createTransaction(db, optionsGenerator(DBMode.readwrite, storeName, e => obs.error(e)));\n        const objectStore = transaction.objectStore(storeName);\n        items.forEach((item, index) => {\n          const request = objectStore.put(item);\n          if (index === items.length - 1) {\n            request.onsuccess = evt => {\n              transaction.commit();\n              obs.next(evt.target.result);\n              obs.complete();\n            };\n          }\n          request.onerror = evt => {\n            transaction.abort();\n            obs.error(evt);\n          };\n        });\n      }).catch(reason => {\n        transaction?.abort();\n        obs.error(reason);\n      });\n    });\n  }\n  /**\n   * Returns all items from the store after delete.\n   * @param storeName The name of the store to have the entry deleted\n   * @param key The key of the entry to be deleted\n   */\n  delete(storeName, key) {\n    return new Observable(obs => {\n      openDatabase(this.indexedDB, this.dbConfig.name, this.dbConfig.version).then(db => {\n        validateBeforeTransaction(db, storeName, e => obs.error(e));\n        const transaction = createTransaction(db, optionsGenerator(DBMode.readwrite, storeName, e => obs.error(e)));\n        const objectStore = transaction.objectStore(storeName);\n        objectStore.delete(key);\n        transaction.oncomplete = () => {\n          this.getAll(storeName).pipe(take(1)).subscribe(newValues => {\n            obs.next(newValues);\n            obs.complete();\n          });\n        };\n      }).catch(reason => obs.error(reason));\n    });\n  }\n  /**\n   * Returns true from the store after a successful delete.\n   * @param storeName The name of the store to have the entry deleted\n   * @param key The key of the entry to be deleted\n   */\n  deleteByKey(storeName, key) {\n    return new Observable(obs => {\n      openDatabase(this.indexedDB, this.dbConfig.name, this.dbConfig.version).then(db => {\n        validateBeforeTransaction(db, storeName, e => obs.error(e));\n        const transaction = createTransaction(db, optionsGenerator(DBMode.readwrite, storeName, e => obs.error(e)));\n        const objectStore = transaction.objectStore(storeName);\n        transaction.oncomplete = () => {\n          obs.next(true);\n          obs.complete();\n        };\n        objectStore.delete(key);\n      }).catch(reason => obs.error(reason));\n    });\n  }\n  /**\n   * Returns true if successfully delete all entries from the store.\n   * @param storeName The name of the store to have the entries deleted\n   */\n  clear(storeName) {\n    return new Observable(obs => {\n      openDatabase(this.indexedDB, this.dbConfig.name, this.dbConfig.version).then(db => {\n        validateBeforeTransaction(db, storeName, e => obs.error(e));\n        const transaction = createTransaction(db, optionsGenerator(DBMode.readwrite, storeName, e => obs.error(e)));\n        const objectStore = transaction.objectStore(storeName);\n        objectStore.clear();\n        transaction.oncomplete = () => {\n          obs.next(true);\n          obs.complete();\n        };\n      }).catch(reason => obs.error(reason));\n    });\n  }\n  /**\n   * Returns true if successfully delete the DB.\n   */\n  deleteDatabase() {\n    var _this = this;\n    return new Observable(obs => {\n      openDatabase(this.indexedDB, this.dbConfig.name, this.dbConfig.version).then( /*#__PURE__*/function () {\n        var _ref3 = _asyncToGenerator(function* (db) {\n          yield db.close();\n          const deleteDBRequest = _this.indexedDB.deleteDatabase(_this.dbConfig.name);\n          deleteDBRequest.onsuccess = () => {\n            obs.next(true);\n            obs.complete();\n          };\n          deleteDBRequest.onerror = error => obs.error(error);\n          deleteDBRequest.onblocked = () => {\n            throw new Error(`Unable to delete database because it's blocked`);\n          };\n        });\n        return function (_x3) {\n          return _ref3.apply(this, arguments);\n        };\n      }()).catch(error => obs.error(error));\n    });\n  }\n  /**\n   * Returns the open cursor event\n   * @param storeName The name of the store to have the entries deleted\n   * @param keyRange The key range which the cursor should be open on\n   */\n  openCursor(storeName, keyRange) {\n    return new Observable(obs => {\n      openDatabase(this.indexedDB, this.dbConfig.name, this.dbConfig.version).then(db => {\n        validateBeforeTransaction(db, storeName, e => obs.error(e));\n        const transaction = createTransaction(db, optionsGenerator(DBMode.readonly, storeName, obs.error));\n        const objectStore = transaction.objectStore(storeName);\n        const request = keyRange === undefined ? objectStore.openCursor() : objectStore.openCursor(keyRange);\n        request.onsuccess = event => {\n          obs.next(event);\n          obs.complete();\n        };\n      }).catch(reason => obs.error(reason));\n    });\n  }\n  /**\n   * Open a cursor by index filter.\n   * @param storeName The name of the store to query.\n   * @param indexName The index name to filter.\n   * @param keyRange The range value and criteria to apply on the index.\n   */\n  openCursorByIndex(storeName, indexName, keyRange, mode = DBMode.readonly) {\n    const obs = new Subject();\n    openDatabase(this.indexedDB, this.dbConfig.name, this.dbConfig.version).then(db => {\n      validateBeforeTransaction(db, storeName, reason => {\n        obs.error(reason);\n      });\n      const transaction = createTransaction(db, optionsGenerator(mode, storeName, reason => {\n        obs.error(reason);\n      }, () => {\n        obs.next();\n      }));\n      const objectStore = transaction.objectStore(storeName);\n      const index = objectStore.index(indexName);\n      const request = index.openCursor(keyRange);\n      request.onsuccess = event => {\n        obs.next(event);\n      };\n    }).catch(reason => obs.error(reason));\n    return obs;\n  }\n  /**\n   * Returns all items by an index.\n   * @param storeName The name of the store to query\n   * @param indexName The index name to filter\n   * @param keyRange  The range value and criteria to apply on the index.\n   */\n  getAllByIndex(storeName, indexName, keyRange) {\n    const data = [];\n    return new Observable(obs => {\n      openDatabase(this.indexedDB, this.dbConfig.name, this.dbConfig.version).then(db => {\n        validateBeforeTransaction(db, storeName, e => obs.error(e));\n        const transaction = createTransaction(db, optionsGenerator(DBMode.readonly, storeName, obs.error));\n        const objectStore = transaction.objectStore(storeName);\n        const index = objectStore.index(indexName);\n        const request = index.openCursor(keyRange);\n        request.onsuccess = event => {\n          const cursor = event.target.result;\n          if (cursor) {\n            data.push(cursor.value);\n            cursor.continue();\n          } else {\n            obs.next(data);\n            obs.complete();\n          }\n        };\n      }).catch(reason => obs.error(reason));\n    });\n  }\n  /**\n   * Returns all primary keys by an index.\n   * @param storeName The name of the store to query\n   * @param indexName The index name to filter\n   * @param keyRange  The range value and criteria to apply on the index.\n   */\n  getAllKeysByIndex(storeName, indexName, keyRange) {\n    const data = [];\n    return new Observable(obs => {\n      openDatabase(this.indexedDB, this.dbConfig.name, this.dbConfig.version).then(db => {\n        validateBeforeTransaction(db, storeName, e => obs.error(e));\n        const transaction = createTransaction(db, optionsGenerator(DBMode.readonly, storeName, obs.error));\n        const objectStore = transaction.objectStore(storeName);\n        const index = objectStore.index(indexName);\n        const request = index.openKeyCursor(keyRange);\n        request.onsuccess = event => {\n          const cursor = event.target.result;\n          if (cursor) {\n            data.push({\n              primaryKey: cursor.primaryKey,\n              key: cursor.key\n            });\n            cursor.continue();\n          } else {\n            obs.next(data);\n            obs.complete();\n          }\n        };\n      }).catch(reason => obs.error(reason));\n    });\n  }\n  /**\n   * Returns the number of rows in a store.\n   * @param storeName The name of the store to query\n   * @param keyRange  The range value and criteria to apply.\n   */\n  count(storeName, keyRange) {\n    return new Observable(obs => {\n      openDatabase(this.indexedDB, this.dbConfig.name, this.dbConfig.version).then(db => {\n        validateBeforeTransaction(db, storeName, e => obs.error(e));\n        const transaction = createTransaction(db, optionsGenerator(DBMode.readonly, storeName, obs.error));\n        const objectStore = transaction.objectStore(storeName);\n        const request = objectStore.count(keyRange);\n        request.onerror = e => obs.error(e);\n        request.onsuccess = e => {\n          obs.next(e.target.result);\n          obs.complete();\n        };\n      }).catch(reason => obs.error(reason));\n    });\n  }\n  /**\n   * Returns the number of rows in a store.\n   * @param storeName The name of the store to query\n   * @param keyRange  The range value and criteria to apply.\n   */\n  countByIndex(storeName, indexName, keyRange) {\n    return new Observable(obs => {\n      openDatabase(this.indexedDB, this.dbConfig.name, this.dbConfig.version).then(db => {\n        validateBeforeTransaction(db, storeName, e => obs.error(e));\n        const transaction = createTransaction(db, optionsGenerator(DBMode.readonly, storeName, obs.error));\n        const objectStore = transaction.objectStore(storeName);\n        const index = objectStore.index(indexName);\n        const request = index.count(keyRange);\n        request.onerror = e => obs.error(e);\n        request.onsuccess = e => {\n          obs.next(e.target.result);\n          obs.complete();\n        };\n      }).catch(reason => obs.error(reason));\n    });\n  }\n  /**\n   * Delete the store by name.\n   * @param storeName The name of the store to query\n   */\n  deleteObjectStore(storeName) {\n    return DeleteObjectStore(this.dbConfig.name, ++this.dbConfig.version, storeName);\n  }\n}\nNgxIndexedDBService.ɵfac = function NgxIndexedDBService_Factory(t) {\n  return new (t || NgxIndexedDBService)(i0.ɵɵinject(CONFIG_TOKEN), i0.ɵɵinject(PLATFORM_ID));\n};\nNgxIndexedDBService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: NgxIndexedDBService,\n  factory: NgxIndexedDBService.ɵfac\n});\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(NgxIndexedDBService, [{\n    type: Injectable\n  }], function () {\n    return [{\n      type: undefined,\n      decorators: [{\n        type: Inject,\n        args: [CONFIG_TOKEN]\n      }]\n    }, {\n      type: undefined,\n      decorators: [{\n        type: Inject,\n        args: [PLATFORM_ID]\n      }]\n    }];\n  }, null);\n})();\nclass NgxIndexedDBModule {\n  static forRoot(...dbConfigs) {\n    const value = {};\n    for (const dbConfig of dbConfigs) {\n      Object.assign(value, {\n        [dbConfig.name]: dbConfig\n      });\n    }\n    return {\n      ngModule: NgxIndexedDBModule,\n      providers: [NgxIndexedDBService, {\n        provide: CONFIG_TOKEN,\n        useValue: value\n      }]\n    };\n  }\n}\nNgxIndexedDBModule.ɵfac = function NgxIndexedDBModule_Factory(t) {\n  return new (t || NgxIndexedDBModule)();\n};\nNgxIndexedDBModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n  type: NgxIndexedDBModule\n});\nNgxIndexedDBModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n  imports: [CommonModule]\n});\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(NgxIndexedDBModule, [{\n    type: NgModule,\n    args: [{\n      declarations: [],\n      imports: [CommonModule]\n    }]\n  }], null, null);\n})();\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { CONFIG_TOKEN, DBMode, NgxIndexedDBModule, NgxIndexedDBService };","map":{"version":3,"names":["i0","InjectionToken","PLATFORM_ID","Injectable","Inject","NgModule","isPlatformBrowser","CommonModule","Observable","from","combineLatest","Subject","take","openDatabase","indexedDB","dbName","version","upgradeCallback","Promise","resolve","reject","request","open","db","onsuccess","event","result","onerror","error","onupgradeneeded","CreateObjectStore","storeSchemas","migrationFactory","database","target","forEach","storeSchema","objectStoreNames","contains","store","objectStore","createObjectStore","storeConfig","schema","createIndex","name","keypath","options","storeMigrations","Object","keys","map","k","parseInt","filter","v","oldVersion","sort","a","b","transaction","close","e","DeleteObjectStore","storeName","Error","obs","newVersion","deleteObjectStore","console","log","next","complete","validateStoreName","validateBeforeTransaction","createTransaction","trans","dbMode","onabort","abort","optionsGenerator","type","DBMode","CONFIG_TOKEN","NgxIndexedDBService","constructor","dbConfigs","platformId","defaultDatabaseName","isBrowser","window","mozIndexedDB","webkitIndexedDB","msIndexedDB","values","isOnlyConfig","length","dbConfig","instanciateConfig","isDefault","selectedDb","objectStoresMeta","then","process","env","NODE_ENV","warn","selectDb","databaseName","includes","add","value","key","readwrite","Boolean","evt","getRequest","get","catch","bulkAdd","promises","results","resolve1","reject1","all","reason","bulkDelete","delete","oncomplete","getAll","pipe","subscribe","newValues","getByKey","readonly","bulkGet","observables","getByID","id","getByIndex","indexName","index","ResultAll","update","put","bulkPut","items","item","commit","deleteByKey","clear","deleteDatabase","deleteDBRequest","onblocked","openCursor","keyRange","undefined","openCursorByIndex","mode","getAllByIndex","data","cursor","push","continue","getAllKeysByIndex","openKeyCursor","primaryKey","count","countByIndex","ɵfac","ɵprov","decorators","args","NgxIndexedDBModule","forRoot","assign","ngModule","providers","provide","useValue","ɵmod","ɵinj","declarations","imports"],"sources":["/home/naser/workspace/communer/share-location/node_modules/ngx-indexed-db/fesm2020/ngx-indexed-db.mjs"],"sourcesContent":["import * as i0 from '@angular/core';\nimport { InjectionToken, PLATFORM_ID, Injectable, Inject, NgModule } from '@angular/core';\nimport { isPlatformBrowser, CommonModule } from '@angular/common';\nimport { Observable, from, combineLatest, Subject } from 'rxjs';\nimport { take } from 'rxjs/operators';\n\nfunction openDatabase(indexedDB, dbName, version, upgradeCallback) {\n    return new Promise((resolve, reject) => {\n        if (!indexedDB) {\n            reject('IndexedDB not available');\n        }\n        const request = indexedDB.open(dbName, version);\n        let db;\n        request.onsuccess = (event) => {\n            db = request.result;\n            resolve(db);\n        };\n        request.onerror = (event) => {\n            reject(`IndexedDB error: ${request.error}`);\n        };\n        if (typeof upgradeCallback === 'function') {\n            request.onupgradeneeded = (event) => {\n                upgradeCallback(event, db);\n            };\n        }\n    });\n}\nfunction CreateObjectStore(indexedDB, dbName, version, storeSchemas, migrationFactory) {\n    if (!indexedDB) {\n        return;\n    }\n    const request = indexedDB.open(dbName, version);\n    request.onupgradeneeded = (event) => {\n        const database = event.target.result;\n        storeSchemas.forEach((storeSchema) => {\n            if (!database.objectStoreNames.contains(storeSchema.store)) {\n                const objectStore = database.createObjectStore(storeSchema.store, storeSchema.storeConfig);\n                storeSchema.storeSchema.forEach((schema) => {\n                    objectStore.createIndex(schema.name, schema.keypath, schema.options);\n                });\n            }\n        });\n        const storeMigrations = migrationFactory && migrationFactory();\n        if (storeMigrations) {\n            Object.keys(storeMigrations)\n                .map((k) => parseInt(k, 10))\n                .filter((v) => v > event.oldVersion)\n                .sort((a, b) => a - b)\n                .forEach((v) => {\n                storeMigrations[v](database, request.transaction);\n            });\n        }\n        database.close();\n    };\n    request.onsuccess = (e) => {\n        e.target.result.close();\n    };\n}\nfunction DeleteObjectStore(dbName, version, storeName) {\n    if (!dbName || !version || !storeName) {\n        throw Error('Params: \"dbName\", \"version\", \"storeName\" are mandatory.');\n    }\n    return new Observable((obs) => {\n        try {\n            const newVersion = version + 1;\n            const request = indexedDB.open(dbName, newVersion);\n            request.onupgradeneeded = (event) => {\n                const database = event.target.result;\n                database.deleteObjectStore(storeName);\n                database.close();\n                console.log('onupgradeneeded');\n                obs.next(true);\n                obs.complete();\n            };\n            request.onerror = (e) => obs.error(e);\n        }\n        catch (error) {\n            obs.error(error);\n        }\n    });\n}\n\nfunction validateStoreName(db, storeName) {\n    return db.objectStoreNames.contains(storeName);\n}\nfunction validateBeforeTransaction(db, storeName, reject) {\n    if (!db) {\n        reject('You need to use the openDatabase function to create a database before you query it!');\n    }\n    if (!validateStoreName(db, storeName)) {\n        reject(`objectStore does not exists: ${storeName}`);\n    }\n}\nfunction createTransaction(db, options) {\n    const trans = db.transaction(options.storeName, options.dbMode);\n    trans.onerror = options.error;\n    trans.onabort = options.abort;\n    return trans;\n}\nfunction optionsGenerator(type, storeName, reject, resolve) {\n    return {\n        storeName,\n        dbMode: type,\n        error: (e) => {\n            reject(e);\n        },\n        abort: (e) => {\n            reject(e);\n        },\n    };\n}\n\nvar DBMode;\n(function (DBMode) {\n    DBMode[\"readonly\"] = \"readonly\";\n    DBMode[\"readwrite\"] = \"readwrite\";\n})(DBMode || (DBMode = {}));\nconst CONFIG_TOKEN = new InjectionToken(null);\n\nclass NgxIndexedDBService {\n    constructor(dbConfigs, platformId) {\n        this.dbConfigs = dbConfigs;\n        this.platformId = platformId;\n        this.defaultDatabaseName = null;\n        this.isBrowser = isPlatformBrowser(this.platformId);\n        if (this.isBrowser) {\n            this.indexedDB =\n                window.indexedDB ||\n                    window.mozIndexedDB ||\n                    window.webkitIndexedDB ||\n                    window.msIndexedDB;\n            const dbConfigs = Object.values(this.dbConfigs);\n            const isOnlyConfig = dbConfigs.length === 1;\n            for (const dbConfig of dbConfigs) {\n                this.instanciateConfig(dbConfig, isOnlyConfig);\n            }\n        }\n    }\n    instanciateConfig(dbConfig, isOnlyConfig) {\n        if (!dbConfig.name) {\n            throw new Error('NgxIndexedDB: Please, provide the dbName in the configuration');\n        }\n        if (!dbConfig.version) {\n            throw new Error('NgxIndexedDB: Please, provide the db version in the configuration');\n        }\n        if ((dbConfig.isDefault ?? false) && this.defaultDatabaseName) {\n            // A default DB is already configured, throw an error\n            throw new Error('NgxIndexedDB: Only one database can be set as default');\n        }\n        if (((dbConfig.isDefault ?? false) && !this.defaultDatabaseName) || isOnlyConfig) {\n            this.defaultDatabaseName = dbConfig.name;\n            this.selectedDb = dbConfig.name;\n        }\n        CreateObjectStore(this.indexedDB, dbConfig.name, dbConfig.version, dbConfig.objectStoresMeta, dbConfig.migrationFactory);\n        openDatabase(this.indexedDB, dbConfig.name).then((db) => {\n            if (db.version !== dbConfig.version) {\n                if (process.env.NODE_ENV !== 'production') {\n                    console.warn(`\n            Your DB Config doesn't match the most recent version of the DB with name ${dbConfig.name}, please update it\n            DB current version: ${db.version};\n            Your configuration: ${dbConfig.version};\n            `);\n                    console.warn(`Using latest version ${db.version}`);\n                }\n                this.dbConfigs[dbConfig.name].version = db.version;\n            }\n        });\n    }\n    get dbConfig() {\n        return this.dbConfigs[this.selectedDb];\n    }\n    /**\n     * Selects a database for the current context.\n     * @param {string} [databaseName=undefined] Database name to select.\n     */\n    selectDb(databaseName) {\n        databaseName = databaseName ?? this.defaultDatabaseName;\n        if (!databaseName) {\n            // Name is still null, it means that there is no default database set\n            // and the database name was not specified while calling a method\n            throw new Error(`No database name specified and no default database set.`);\n        }\n        if (!Object.keys(this.dbConfigs).includes(databaseName)) {\n            throw new Error(`NgxIndexedDB: Database ${databaseName} is not initialized.`);\n        }\n        this.selectedDb = databaseName;\n    }\n    /**\n     * Allows to crate a new object store ad-hoc\n     * @param storeName The name of the store to be created\n     * @param migrationFactory The migration factory if exists\n     */\n    createObjectStore(storeSchema, migrationFactory) {\n        const storeSchemas = [storeSchema];\n        CreateObjectStore(this.indexedDB, this.dbConfig.name, ++this.dbConfig.version, storeSchemas, migrationFactory);\n    }\n    /**\n     * Adds new entry in the store and returns its key\n     * @param storeName The name of the store to add the item\n     * @param value The entry to be added\n     * @param key The optional key for the entry\n     */\n    add(storeName, value, key) {\n        return new Observable((obs) => {\n            openDatabase(this.indexedDB, this.dbConfig.name, this.dbConfig.version)\n                .then((db) => {\n                const transaction = createTransaction(db, optionsGenerator(DBMode.readwrite, storeName, (e) => obs.error(e)));\n                const objectStore = transaction.objectStore(storeName);\n                const request = Boolean(key) ? objectStore.add(value, key) : objectStore.add(value);\n                request.onsuccess = async (evt) => {\n                    const result = evt.target.result;\n                    const getRequest = objectStore.get(result);\n                    getRequest.onsuccess = (event) => {\n                        obs.next(event.target.result);\n                        obs.complete();\n                    };\n                    getRequest.onerror = (event) => {\n                        obs.error(event);\n                    };\n                };\n                request.onerror = (event) => {\n                    obs.error(event);\n                };\n            })\n                .catch((error) => obs.error(error));\n        });\n    }\n    /**\n     * Adds new entries in the store and returns its key\n     * @param storeName The name of the store to add the item\n     * @param values The entries to be added containing optional key attribute\n     */\n    bulkAdd(storeName, values) {\n        const promises = new Promise((resolve, reject) => {\n            openDatabase(this.indexedDB, this.dbConfig.name, this.dbConfig.version)\n                .then((db) => {\n                const transaction = createTransaction(db, optionsGenerator(DBMode.readwrite, storeName, resolve, reject));\n                const objectStore = transaction.objectStore(storeName);\n                const results = values.map((value) => {\n                    return new Promise((resolve1, reject1) => {\n                        const key = value.key;\n                        delete value.key;\n                        const request = Boolean(key)\n                            ? objectStore.add(value, key)\n                            : objectStore.add(value);\n                        request.onsuccess = (evt) => {\n                            const result = evt.target.result;\n                            resolve1(result);\n                        };\n                    });\n                });\n                resolve(Promise.all(results));\n            })\n                .catch((reason) => reject(reason));\n        });\n        return from(promises);\n    }\n    /**\n     * Delete entries in the store and returns current entries in the store\n     * @param storeName The name of the store to add the item\n     * @param keys The keys to be deleted\n     */\n    bulkDelete(storeName, keys) {\n        const promises = keys.map((key) => {\n            return new Promise((resolve, reject) => {\n                openDatabase(this.indexedDB, this.dbConfig.name, this.dbConfig.version)\n                    .then((db) => {\n                    const transaction = createTransaction(db, optionsGenerator(DBMode.readwrite, storeName, reject, resolve));\n                    const objectStore = transaction.objectStore(storeName);\n                    objectStore.delete(key);\n                    transaction.oncomplete = () => {\n                        this.getAll(storeName)\n                            .pipe(take(1))\n                            .subscribe((newValues) => {\n                            resolve(newValues);\n                        });\n                    };\n                })\n                    .catch((reason) => reject(reason));\n            });\n        });\n        return from(Promise.all(promises));\n    }\n    /**\n     * Returns entry by key.\n     * @param storeName The name of the store to query\n     * @param key The entry key\n     */\n    getByKey(storeName, key) {\n        return new Observable((obs) => {\n            openDatabase(this.indexedDB, this.dbConfig.name, this.dbConfig.version)\n                .then((db) => {\n                const transaction = createTransaction(db, optionsGenerator(DBMode.readonly, storeName, obs.error));\n                const objectStore = transaction.objectStore(storeName);\n                const request = objectStore.get(key);\n                request.onsuccess = (event) => {\n                    obs.next(event.target.result);\n                    obs.complete();\n                };\n                request.onerror = (event) => {\n                    obs.error(event);\n                };\n            })\n                .catch((error) => obs.error(error));\n        });\n    }\n    /**\n     * Retrieve multiple entries in the store\n     * @param storeName The name of the store to retrieve the items\n     * @param keys The ids entries to be retrieve\n     */\n    bulkGet(storeName, keys) {\n        const observables = keys.map((key) => this.getByKey(storeName, key));\n        return new Observable((obs) => {\n            combineLatest(observables).subscribe((values) => {\n                obs.next(values);\n                obs.complete();\n            });\n        });\n    }\n    /**\n     * Returns entry by id.\n     * @param storeName The name of the store to query\n     * @param id The entry id\n     */\n    getByID(storeName, id) {\n        return new Observable((obs) => {\n            openDatabase(this.indexedDB, this.dbConfig.name, this.dbConfig.version)\n                .then((db) => {\n                validateBeforeTransaction(db, storeName, (e) => obs.error(e));\n                const transaction = createTransaction(db, optionsGenerator(DBMode.readonly, storeName, obs.error, obs.next));\n                const objectStore = transaction.objectStore(storeName);\n                const request = objectStore.get(id);\n                request.onsuccess = (event) => {\n                    obs.next(event.target.result);\n                };\n            })\n                .catch((error) => obs.error(error));\n        });\n    }\n    /**\n     * Returns entry by index.\n     * @param storeName The name of the store to query\n     * @param indexName The index name to filter\n     * @param key The entry key.\n     */\n    getByIndex(storeName, indexName, key) {\n        return new Observable((obs) => {\n            openDatabase(this.indexedDB, this.dbConfig.name, this.dbConfig.version)\n                .then((db) => {\n                validateBeforeTransaction(db, storeName, (e) => obs.error(e));\n                const transaction = createTransaction(db, optionsGenerator(DBMode.readonly, storeName, obs.error));\n                const objectStore = transaction.objectStore(storeName);\n                const index = objectStore.index(indexName);\n                const request = index.get(key);\n                request.onsuccess = (event) => {\n                    obs.next(event.target.result);\n                    obs.complete();\n                };\n            })\n                .catch((reason) => obs.error(reason));\n        });\n    }\n    /**\n     * Return all elements from one store\n     * @param storeName The name of the store to select the items\n     */\n    getAll(storeName) {\n        return new Observable((obs) => {\n            openDatabase(this.indexedDB, this.dbConfig.name, this.dbConfig.version)\n                .then((db) => {\n                validateBeforeTransaction(db, storeName, (e) => obs.error(e));\n                const transaction = createTransaction(db, optionsGenerator(DBMode.readonly, storeName, obs.error, obs.next));\n                const objectStore = transaction.objectStore(storeName);\n                const request = objectStore.getAll();\n                request.onerror = (evt) => {\n                    obs.error(evt);\n                };\n                request.onsuccess = ({ target: { result: ResultAll } }) => {\n                    obs.next(ResultAll);\n                    obs.complete();\n                };\n            })\n                .catch((error) => obs.error(error));\n        });\n    }\n    /**\n     * Adds or updates a record in store with the given value and key. Return all items present in the store\n     * @param storeName The name of the store to update\n     * @param value The new value for the entry\n     */\n    update(storeName, value) {\n        return new Observable((obs) => {\n            openDatabase(this.indexedDB, this.dbConfig.name, this.dbConfig.version)\n                .then((db) => {\n                validateBeforeTransaction(db, storeName, (e) => obs.error(e));\n                const transaction = createTransaction(db, optionsGenerator(DBMode.readwrite, storeName, (e) => obs.error(e)));\n                const objectStore = transaction.objectStore(storeName);\n                const request = objectStore.put(value);\n                request.onsuccess = async (evt) => {\n                    const result = evt.target.result;\n                    const getRequest = objectStore.get(result);\n                    getRequest.onsuccess = (event) => {\n                        obs.next(event.target.result);\n                        obs.complete();\n                    };\n                };\n            })\n                .catch((reason) => obs.error(reason));\n        });\n    }\n    /**\n     * Adds or updates a record in store with the given value and key. Return all items present in the store\n     * @param storeName The name of the store to update\n     * @param items The values to insert in the DB\n     *\n     * @Return The return value is an Observable with the primary key of the object that was last in given array\n     *\n     * @error If the call to bulkPut fails the transaction will be aborted and previously inserted entities will be deleted\n     */\n    bulkPut(storeName, items) {\n        let transaction;\n        return new Observable((obs) => {\n            openDatabase(this.indexedDB, this.dbConfig.name, this.dbConfig.version)\n                .then((db) => {\n                validateBeforeTransaction(db, storeName, e => obs.error(e));\n                transaction = createTransaction(db, optionsGenerator(DBMode.readwrite, storeName, (e) => obs.error(e)));\n                const objectStore = transaction.objectStore(storeName);\n                items.forEach((item, index) => {\n                    const request = objectStore.put(item);\n                    if (index === items.length - 1) {\n                        request.onsuccess = (evt) => {\n                            transaction.commit();\n                            obs.next(evt.target.result);\n                            obs.complete();\n                        };\n                    }\n                    request.onerror = (evt) => {\n                        transaction.abort();\n                        obs.error(evt);\n                    };\n                });\n            })\n                .catch((reason) => {\n                transaction?.abort();\n                obs.error(reason);\n            });\n        });\n    }\n    /**\n     * Returns all items from the store after delete.\n     * @param storeName The name of the store to have the entry deleted\n     * @param key The key of the entry to be deleted\n     */\n    delete(storeName, key) {\n        return new Observable((obs) => {\n            openDatabase(this.indexedDB, this.dbConfig.name, this.dbConfig.version)\n                .then((db) => {\n                validateBeforeTransaction(db, storeName, (e) => obs.error(e));\n                const transaction = createTransaction(db, optionsGenerator(DBMode.readwrite, storeName, (e) => obs.error(e)));\n                const objectStore = transaction.objectStore(storeName);\n                objectStore.delete(key);\n                transaction.oncomplete = () => {\n                    this.getAll(storeName)\n                        .pipe(take(1))\n                        .subscribe((newValues) => {\n                        obs.next(newValues);\n                        obs.complete();\n                    });\n                };\n            })\n                .catch((reason) => obs.error(reason));\n        });\n    }\n    /**\n     * Returns true from the store after a successful delete.\n     * @param storeName The name of the store to have the entry deleted\n     * @param key The key of the entry to be deleted\n     */\n    deleteByKey(storeName, key) {\n        return new Observable((obs) => {\n            openDatabase(this.indexedDB, this.dbConfig.name, this.dbConfig.version)\n                .then((db) => {\n                validateBeforeTransaction(db, storeName, (e) => obs.error(e));\n                const transaction = createTransaction(db, optionsGenerator(DBMode.readwrite, storeName, (e) => obs.error(e)));\n                const objectStore = transaction.objectStore(storeName);\n                transaction.oncomplete = () => {\n                    obs.next(true);\n                    obs.complete();\n                };\n                objectStore.delete(key);\n            })\n                .catch((reason) => obs.error(reason));\n        });\n    }\n    /**\n     * Returns true if successfully delete all entries from the store.\n     * @param storeName The name of the store to have the entries deleted\n     */\n    clear(storeName) {\n        return new Observable((obs) => {\n            openDatabase(this.indexedDB, this.dbConfig.name, this.dbConfig.version)\n                .then((db) => {\n                validateBeforeTransaction(db, storeName, (e) => obs.error(e));\n                const transaction = createTransaction(db, optionsGenerator(DBMode.readwrite, storeName, (e) => obs.error(e)));\n                const objectStore = transaction.objectStore(storeName);\n                objectStore.clear();\n                transaction.oncomplete = () => {\n                    obs.next(true);\n                    obs.complete();\n                };\n            })\n                .catch((reason) => obs.error(reason));\n        });\n    }\n    /**\n     * Returns true if successfully delete the DB.\n     */\n    deleteDatabase() {\n        return new Observable((obs) => {\n            openDatabase(this.indexedDB, this.dbConfig.name, this.dbConfig.version)\n                .then(async (db) => {\n                await db.close();\n                const deleteDBRequest = this.indexedDB.deleteDatabase(this.dbConfig.name);\n                deleteDBRequest.onsuccess = () => {\n                    obs.next(true);\n                    obs.complete();\n                };\n                deleteDBRequest.onerror = (error) => obs.error(error);\n                deleteDBRequest.onblocked = () => {\n                    throw new Error(`Unable to delete database because it's blocked`);\n                };\n            })\n                .catch((error) => obs.error(error));\n        });\n    }\n    /**\n     * Returns the open cursor event\n     * @param storeName The name of the store to have the entries deleted\n     * @param keyRange The key range which the cursor should be open on\n     */\n    openCursor(storeName, keyRange) {\n        return new Observable((obs) => {\n            openDatabase(this.indexedDB, this.dbConfig.name, this.dbConfig.version)\n                .then((db) => {\n                validateBeforeTransaction(db, storeName, (e) => obs.error(e));\n                const transaction = createTransaction(db, optionsGenerator(DBMode.readonly, storeName, obs.error));\n                const objectStore = transaction.objectStore(storeName);\n                const request = keyRange === undefined ? objectStore.openCursor() : objectStore.openCursor(keyRange);\n                request.onsuccess = (event) => {\n                    obs.next(event);\n                    obs.complete();\n                };\n            })\n                .catch((reason) => obs.error(reason));\n        });\n    }\n    /**\n     * Open a cursor by index filter.\n     * @param storeName The name of the store to query.\n     * @param indexName The index name to filter.\n     * @param keyRange The range value and criteria to apply on the index.\n     */\n    openCursorByIndex(storeName, indexName, keyRange, mode = DBMode.readonly) {\n        const obs = new Subject();\n        openDatabase(this.indexedDB, this.dbConfig.name, this.dbConfig.version)\n            .then((db) => {\n            validateBeforeTransaction(db, storeName, (reason) => {\n                obs.error(reason);\n            });\n            const transaction = createTransaction(db, optionsGenerator(mode, storeName, (reason) => {\n                obs.error(reason);\n            }, () => {\n                obs.next();\n            }));\n            const objectStore = transaction.objectStore(storeName);\n            const index = objectStore.index(indexName);\n            const request = index.openCursor(keyRange);\n            request.onsuccess = (event) => {\n                obs.next(event);\n            };\n        })\n            .catch((reason) => obs.error(reason));\n        return obs;\n    }\n    /**\n     * Returns all items by an index.\n     * @param storeName The name of the store to query\n     * @param indexName The index name to filter\n     * @param keyRange  The range value and criteria to apply on the index.\n     */\n    getAllByIndex(storeName, indexName, keyRange) {\n        const data = [];\n        return new Observable((obs) => {\n            openDatabase(this.indexedDB, this.dbConfig.name, this.dbConfig.version)\n                .then((db) => {\n                validateBeforeTransaction(db, storeName, (e) => obs.error(e));\n                const transaction = createTransaction(db, optionsGenerator(DBMode.readonly, storeName, obs.error));\n                const objectStore = transaction.objectStore(storeName);\n                const index = objectStore.index(indexName);\n                const request = index.openCursor(keyRange);\n                request.onsuccess = (event) => {\n                    const cursor = event.target.result;\n                    if (cursor) {\n                        data.push(cursor.value);\n                        cursor.continue();\n                    }\n                    else {\n                        obs.next(data);\n                        obs.complete();\n                    }\n                };\n            })\n                .catch((reason) => obs.error(reason));\n        });\n    }\n    /**\n     * Returns all primary keys by an index.\n     * @param storeName The name of the store to query\n     * @param indexName The index name to filter\n     * @param keyRange  The range value and criteria to apply on the index.\n     */\n    getAllKeysByIndex(storeName, indexName, keyRange) {\n        const data = [];\n        return new Observable((obs) => {\n            openDatabase(this.indexedDB, this.dbConfig.name, this.dbConfig.version)\n                .then((db) => {\n                validateBeforeTransaction(db, storeName, (e) => obs.error(e));\n                const transaction = createTransaction(db, optionsGenerator(DBMode.readonly, storeName, obs.error));\n                const objectStore = transaction.objectStore(storeName);\n                const index = objectStore.index(indexName);\n                const request = index.openKeyCursor(keyRange);\n                request.onsuccess = (event) => {\n                    const cursor = event.target.result;\n                    if (cursor) {\n                        data.push({ primaryKey: cursor.primaryKey, key: cursor.key });\n                        cursor.continue();\n                    }\n                    else {\n                        obs.next(data);\n                        obs.complete();\n                    }\n                };\n            })\n                .catch((reason) => obs.error(reason));\n        });\n    }\n    /**\n     * Returns the number of rows in a store.\n     * @param storeName The name of the store to query\n     * @param keyRange  The range value and criteria to apply.\n     */\n    count(storeName, keyRange) {\n        return new Observable((obs) => {\n            openDatabase(this.indexedDB, this.dbConfig.name, this.dbConfig.version)\n                .then((db) => {\n                validateBeforeTransaction(db, storeName, (e) => obs.error(e));\n                const transaction = createTransaction(db, optionsGenerator(DBMode.readonly, storeName, obs.error));\n                const objectStore = transaction.objectStore(storeName);\n                const request = objectStore.count(keyRange);\n                request.onerror = (e) => obs.error(e);\n                request.onsuccess = (e) => {\n                    obs.next(e.target.result);\n                    obs.complete();\n                };\n            })\n                .catch((reason) => obs.error(reason));\n        });\n    }\n    /**\n     * Returns the number of rows in a store.\n     * @param storeName The name of the store to query\n     * @param keyRange  The range value and criteria to apply.\n     */\n    countByIndex(storeName, indexName, keyRange) {\n        return new Observable((obs) => {\n            openDatabase(this.indexedDB, this.dbConfig.name, this.dbConfig.version)\n                .then((db) => {\n                validateBeforeTransaction(db, storeName, (e) => obs.error(e));\n                const transaction = createTransaction(db, optionsGenerator(DBMode.readonly, storeName, obs.error));\n                const objectStore = transaction.objectStore(storeName);\n                const index = objectStore.index(indexName);\n                const request = index.count(keyRange);\n                request.onerror = (e) => obs.error(e);\n                request.onsuccess = (e) => {\n                    obs.next(e.target.result);\n                    obs.complete();\n                };\n            })\n                .catch((reason) => obs.error(reason));\n        });\n    }\n    /**\n     * Delete the store by name.\n     * @param storeName The name of the store to query\n     */\n    deleteObjectStore(storeName) {\n        return DeleteObjectStore(this.dbConfig.name, ++this.dbConfig.version, storeName);\n    }\n}\nNgxIndexedDBService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"14.2.12\", ngImport: i0, type: NgxIndexedDBService, deps: [{ token: CONFIG_TOKEN }, { token: PLATFORM_ID }], target: i0.ɵɵFactoryTarget.Injectable });\nNgxIndexedDBService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"14.2.12\", ngImport: i0, type: NgxIndexedDBService });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"14.2.12\", ngImport: i0, type: NgxIndexedDBService, decorators: [{\n            type: Injectable\n        }], ctorParameters: function () { return [{ type: undefined, decorators: [{\n                    type: Inject,\n                    args: [CONFIG_TOKEN]\n                }] }, { type: undefined, decorators: [{\n                    type: Inject,\n                    args: [PLATFORM_ID]\n                }] }]; } });\n\nclass NgxIndexedDBModule {\n    static forRoot(...dbConfigs) {\n        const value = {};\n        for (const dbConfig of dbConfigs) {\n            Object.assign(value, { [dbConfig.name]: dbConfig });\n        }\n        return {\n            ngModule: NgxIndexedDBModule,\n            providers: [NgxIndexedDBService, { provide: CONFIG_TOKEN, useValue: value }]\n        };\n    }\n}\nNgxIndexedDBModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"14.2.12\", ngImport: i0, type: NgxIndexedDBModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });\nNgxIndexedDBModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: \"14.0.0\", version: \"14.2.12\", ngImport: i0, type: NgxIndexedDBModule, imports: [CommonModule] });\nNgxIndexedDBModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: \"12.0.0\", version: \"14.2.12\", ngImport: i0, type: NgxIndexedDBModule, imports: [CommonModule] });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"14.2.12\", ngImport: i0, type: NgxIndexedDBModule, decorators: [{\n            type: NgModule,\n            args: [{\n                    declarations: [],\n                    imports: [CommonModule]\n                }]\n        }] });\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { CONFIG_TOKEN, DBMode, NgxIndexedDBModule, NgxIndexedDBService };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}